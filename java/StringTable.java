//
// STRINGTABLE.JAVA
// A hash table mapping Strings to their positions in the the pattern sequence
// You get to fill in the methods for this part.
//
public class StringTable {

	private Record[] table;
	private Record deleted=new Record("deleted");

	/**
	 * This method creates a table.  The updated implementation does not use the maxSize parameter, instead initializing the table to be length 2.
	 * @param maxSize - paramter not used.
	 */
	public StringTable(int maxSize) 
	{
		table = new Record[2];
	}


	/**
	 * This method inserts a record into the table.  It finds the hash value, and sets the hash value within the record itself.  I then iterates until it
	 * finds an empty slot (either null or "deleted" within the table, in which case it inserts the record into the table at that location.  
	 * Because the stepHash key is relatively prime to the length of the table, the iteration terminates when the baseHash value recurs.  
	 * If that is the case, then the table is assumed to be full (in fact, it must be full due to the relatively prime step key used for 
	 * multiplicative hashing), the table size is doubled according to the doubleTable() method, and the insertion is attempted again.  
	 * This method should theoretically never return false.
	 * @param r
	 * @return boolean value indicating if the insert was successful
	 */
	public boolean insert(Record r) 
	{ 
		int key=toHashKey(r.key);
		int base=baseHash(key);
		int step=stepHash(key);
		int slot = base;
		boolean insert=false;
		r.hash=key;
		do{
			if ((table[slot]==null)||(table[slot].key.equals("deleted"))){
				table[slot]=r;
				insert=true;
				return true;
			}	
			slot=(slot+step)%table.length;
		}while(slot!=base); //if the slot sequence repeats, the base will be the first to recur
		if(!insert){
			doubleTable();
			return insert(r);
		}return false;
	}



    /**
     * This method removes records from the table and sets the used slot to "deleted."  It does this in linear time because each record maintains a list of
     * positions within the table.  This method simply looks at that list and sets each position in that list to the pre-made "deleted" record.  
     * After all slots have been changed, it then clears the list of positions in the record provided to ensure that the list of positions is correct. (i.e. empty)
     * @param r
     */
	public void remove(Record r) 
	{
		for(int i=0;i<r.positions.size();i++){
			if(table[r.positions.get(i)]!=null){
				table[r.positions.get(i)]=deleted;
			}
			r.positions.clear();

		}
	}



	/**
	 * This method works by taking a key, hashing its base and step values, and iterating through the hashing sequence according to multiplicative hashing.
	 * If a record slot is not empty (in this case, the slot must be not null, specifically), it first compares the integer hashKey to the record's stored 
	 * hashKey.  If they match, it also does a string compare to ensure that the records are, in fact the same, in order to ensure that we don't accidentally
	 * return a different string that hashes to the same integer.  This loop terminates in one of two cases: we recur at the base slot, or we hit a null array
	 * slot.
	 * @param key
	 * @return the record found with the provided key
	 */
	public Record find(String key){
		int findKey=toHashKey(key);
		int base=baseHash(findKey);
		int step = stepHash(findKey);
		int slot = base;
		while(table[slot]!=null){
			if(findKey==table[slot].hash){
				if(table[slot].key.equals(key)){
					return table[slot];
				}
				
			}
			slot=(slot+step)%table.length;
			if(slot==base){
				break;
			}
		}
		return null;
	}

	/**
	 * This method doubles the table size and reinserts all values from the previous table into the new table, rehashing them due to the new table's length.
	 * It does this by cloning the old array, creating a new array double the length of the old one, and iteratively inserting each element in the old array 
	 * into the new array.  Note that this insert has to examine each slot in the old array individually, because we do not maintain an index of which slots
	 * have records in them.  This is a potential future update that may allow us to speed up this step somewhat.
	 */
	private void doubleTable(){
		Record[] oldTable=table.clone();
		table= new Record[oldTable.length*2];
		for(int i = 0; i< oldTable.length;i++){
			if(oldTable[i]!=null){
				if(oldTable[i].key.equals("deleted")){
					return;
				}else{
					insert(oldTable[i]);
				}
			}
		}
	}


	///////////////////////////////////////////////////////////////////////


	// Convert a String key into an integer that serves as input to hash
	// functions.  This mapping is based on the idea of a linear-congruential
	// pesudorandom number generator, in which successive values r_i are 
	// generated by computing
	//    r_i = ( A * r_(i-1) + B ) mod M
	// A is a large prime number, while B is a small increment thrown in
	// so that we don't just compute successive powers of A mod M.
	//
	// We modify the above generator by perturbing each r_i, adding in
	// the ith character of the string and its offset, to alter the
	// pseudorandom sequence.
	//
	int toHashKey(String s)
	{
		int A = 1952786893;
		int B = 367257;
		int v = B;

		for (int j = 0; j < s.length(); j++)
		{
			char c = s.charAt(j);
			v = A * (v + (int) c + j) + B;
		}

		if (v < 0) v = -v;
		return v;
	}

	/**
	 * This method multiplies the integer hashKey provided 1/2 * squareroot(5) (incidentally, this is phi, the Golden Ratio), subtracts the 
	 * integer floor of this value from itself in order to generate a decimal sequence, and multiplies that sequence by the length of the table and takes
	 * the integer value of that product in order to specify a slot to examine for insertion.
	 * @param hashKey
	 * @return integer hashing value corresponding to the initial slot to check in the array
	 */
	int baseHash(int hashKey)
	{
		double num = .5*Math.sqrt(5)*hashKey;
		double floor = Math.floor(num);
		// Fill in your own hash function here

		return (int)(table.length*(num-floor));
	}

	/**
	 * 
	 * @param hashKey
	 * @return an odd integer value to be used for the step hashing value
	 *  
	 * This method takes an integer value and generates an odd integer less than than the length of the table by multiplying the hashkey by 1/2 times
	 * the square root of a prime number (37 in this case), subtracting the floor of that number, in order to generate a decimal sequence, and multiplying that
	 * sequence by the length of the table and taking that integer value in order to get an integer that describes the number of slots further down the table to check.
	 * Because the length of the table is always a power of two, this method will also add 1 if the generated value is even (or 0), to ensure that it 
	 * is relatively prime with the length of the table.  This means that when it is repeatedly added to the base value modulus the length of the table, the 
	 * first number to recur will be the base value.  Because the table is a power of two, we also return a modulus the length of the table in the event that the
     * generated hash value happens to be the length of the table + 1 after all of the preceding steps
	 */
	int stepHash(int hashKey)
	{
		double num = .5*Math.sqrt(37)*hashKey;
		double floor = Math.floor(num);
		int a = (int)(table.length*(num-floor));
		if ((a%2==0)||(a==0)){
			a+=1;
		}
		return a%table.length;

	}
}
